<template>
  <h2>vue-apollo Mutation</h2>

  <div v-if="!hasSuccessfullyDeletedUser" class="row alert alert-info m-0 mb-3">
    <div class="col-md-12">Copy a User ID above and paste it on the field below then delete the user.</div>
  </div>
  <div v-else class="row alert alert-warning m-0 mb-3">
    <div class="col-md-12">
      Notice that the user has been removed as well from the table. This was done by removing the entry from the cache
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <input v-model.trim="userId" type="text" class="form-control" placeholder="User ID" />
    </div>
    <div class="col-auto">
      <button @click="deleteUser({ userId })" type="submit" class="btn btn-primary mb-3" :disabled="isLoading">
        {{ isLoading ? 'Deleting...' : 'Delete User' }}
      </button>
    </div>
  </div>

  <template v-if="!isLoading && error">
    <div class="alert alert-warning">
      Do note that if you try to interpolate the
      <code>ApolloError</code>
      object directly, it just prints the message.
    </div>
    <pre class="text-danger">{{ error }}</pre>
    <div class="alert alert-warning">For advanced use cases, you might want to do something with the full object.</div>
    <pre class="text-danger">{{ JSON.stringify(error, null, 2) }}</pre>
  </template>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue';
import { useMutation } from '@vue/apollo-composable';
import {
  DeleteUserDocument,
  DeleteUserMutation,
  DeleteUserMutationVariables,
  useDeleteUserMutation,
  UserConnection,
} from '@/generated/graphql';

export const DemoUseMutation = defineComponent({
  name: 'DemoUseMutation',
  setup() {
    const hasSuccessfullyDeletedUser = ref(false);
    const userId = ref<string>('');

    /**
     * Similar to useQuery, if you use the vanilla useMutation, then you'll have to supply the
     * TypeScript types manually which is prone to human error. Fortunately, we have
     * GraphQL Code Generator to heavy lift the process for us.
     */
    useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
      DeleteUserDocument,
      /**
       * Quick note, if you pass the variables directly like the commented code below, it only gets executed once.
       * Meaning whatever the value of the `userId` ref was upon executing this will be the only value acknowledged
       * should you use `mutate()`. Obviously, one way to get around it is to pass a parameter to `mutate()` every
       * time you call it but then it'd look like setting variables here is pointless.
       */
      // { variables: { userId: userId.value } }

      /**
       * Another way to get around that is to pass a function instead. This way, you can just call `mutate()` without
       * passing any parameters to it and it'd still get the latest values of the mapped refs to the variables. You
       * might ask what if you pass additional variables to it? That works too and both objects would merge.
       *
       * Read more at: https://v4.apollo.vuejs.org/guide-composable/mutation.html#variables
       */
      () => ({
        variables: {
          userId: userId.value,
        },
      }),
    );

    /**
     * The mutation generated by the GraphQL Code Generator which basically wraps the vue-apollo way nicely with TypeScript.
     * If you check the signature of the function below, it already has types. Furthermore, if you check the implementation
     * of the function, it's similar to what we did above (vue-apollo way) and we don't have to supply the
     * graphql document anymore.
     */
    useDeleteUserMutation(() => ({ variables: { userId: userId.value } }));

    const {
      /**
       * The meat of mutations. You have to invoke this to execute the mutation.
       * It's best practice to rename it into what it actually does and in this
       * case, it should delete a user.
       */
      mutate: deleteUser,

      /**
       * A ref boolean that holds "true" if the mutation was already called.
       */
      called,

      // Typical variables you'll use
      loading: isLoading,
      error,

      // Event hooks you can attach to if you want to do something when these events occur.
      onError,
      onDone,
    } = useDeleteUserMutation({
      variables: {
        userId: userId.value,
      },

      // You can have policies as well and YMMV. Read more on the docs on which
      // is appropriate for your use case.
      // https://v4.apollo.vuejs.org/guide-composable/error-handling.html#error-policies
      errorPolicy: undefined,

      // Only 'network-only' and 'no-cache' are supported for mutations.
      // Read more on the docs on what these policies exactly do:
      // https://www.apollographql.com/docs/react/data/queries/#supported-fetch-policies
      fetchPolicy: 'network-only',

      /**
       * If you need optimistic response, that's an option as well. Read more on the docs:
       * https://www.apollographql.com/docs/react/performance/optimistic-ui/
       */
      optimisticResponse: undefined,

      /**
       * The following properties below are some ways to do something after the mutation is done.
       */

      /**
       * This one is for updating the cache directly.
       *
       * If you're UPDATING A SINGLE ENTITY, usually that's associated with a unique identifier such as an `id` or `_id` field.
       * Apollo Client will automatically update the cache based on that so you shouldn't need this in that scenario.
       * However if your unique identifier does not use those such as a mix of fields or an entirely different field, you should
       * CUSTOMIZE the Cache ID for that GraphQL Type by defining a Type Policy for it. See docs for more info:
       * https://www.apollographql.com/docs/react/caching/cache-configuration/#customizing-cache-ids
       *
       * If you're CREATING A NEW ENTITY and want that to be reflected on certain active queries, then you should use
       * `refetchQueries` instead. Technically speaking you can still do it here but it'd probably be safer
       * to fetch the shape of the existing queries rather than what this mutation might fetch (could be incomplete).
       * Ultimately, YMMV.
       *
       * However, if for some reason it's not an option to refetch (e.g. it's too expensive to do) or you know what you're doing
       * then proceed with caution. An example from the official docs is given: https://www.apollographql.com/docs/react/data/mutations/#the-update-function
       *
       * If you're DELETING a single entity, this is also a valid place which this demo will show by modifying the cache directly.
       * Exact API: https://www.apollographql.com/docs/react/api/react/hoc/#optionsupdate
       */
      update(cache, { data }) {
        /**
         * Code below is derived from the examples on the official docs.
         * https://www.apollographql.com/docs/react/caching/cache-interaction/#examples
         *
         * It has plenty of examples such as:
         * - REMOVING an item from a list (https://www.apollographql.com/docs/react/caching/cache-interaction/#example-removing-an-item-from-a-list)
         * - ADDING an item to a list (https://www.apollographql.com/docs/react/caching/cache-interaction/#example-adding-an-item-to-a-list)
         * - UPDATING the cache after a mutation (https://www.apollographql.com/docs/react/caching/cache-interaction/#example-updating-the-cache-after-a-mutation)
         * - DELETING a FIELD from a cached object (https://www.apollographql.com/docs/react/caching/cache-interaction/#example-deleting-a-field-from-a-cached-object)
         * - INVALIDATING FIELDS within a cached object (https://www.apollographql.com/docs/react/caching/cache-interaction/#example-invalidating-fields-within-a-cached-object)
         *
         * Their example on removing an item from a list uses an array but we have a connection that's why it looks like this.
         */
        const deletedUserId = data?.deleteUser?.user?.id;

        if (deletedUserId) {
          /**
           * Using cache.modify here: https://www.apollographql.com/docs/react/caching/cache-interaction/#using-cachemodify
           * There are other ways to read and write to the cache as well:
           * - Using GraphQL queries
           * - Using GraphQL fragments
           *
           * Exact API: https://www.apollographql.com/docs/react/api/cache/InMemoryCache/#modify
           */
          cache.modify({
            /**
             * If this is not supplied, then it'll look on the entire cache. For this example, I'm targeting all UserConnection types
             * on the ROOT_QUERY so I'll explicitly set it here. If you have a custom Cache ID or want to target a specific object's
             * fields, you can make use of `cache.identify` to get the cache ID of the cached object.
             * This could be useful in scenarios like deleting a single Comment on a particular Post.
             * https://www.apollographql.com/docs/react/caching/cache-interaction/#obtaining-an-objects-cache-id
             */
            id: 'ROOT_QUERY',

            fields: {
              // IDK if there's any way to make this strongly typed, just my gripe on dealing with
              // the cache directly. Please let me know if you found a way!
              users(existingUsers, { readField }) {
                if (!existingUsers) {
                  return undefined;
                }

                const modifiedUserConnection: UserConnection = {
                  ...existingUsers,
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  edges: existingUsers.edges.filter((edge: any) => {
                    if (!edge) {
                      // This can be an empty space according to the GraphQL Schema of the API (e.g. [UserEdge]!).
                      // So let's not tamper it or we might re-arrange the whole thing and mutate unnecessarily.
                      return true;
                    }

                    /**
                     * Doing the `readField` here is important for this particular case. If the field contains an object type
                     * or a list of objects, those objects are represented as references and each reference points to its
                     * corresponding object in the cache by its Cache ID.
                     * https://www.apollographql.com/docs/react/caching/cache-interaction/#values-vs-references
                     */
                    console.log('edge.node reference:', edge.node);
                    return readField('id', edge.node) !== deletedUserId;
                  }),
                };

                return modifiedUserConnection;
              },
            },
          });
        }
      },

      /**
       * In the scenario that you want certain queries to be refetched after the mutation is done,
       * you can do so here. I recommend reading the docs on usage: https://www.apollographql.com/docs/react/data/mutations/#refetching-queries
       * Exact API: https://www.apollographql.com/docs/react/api/react/hoc/#optionsrefetchqueries
       *
       */
      refetchQueries: undefined,

      /**
       * Queries refetched using `refetchQueries` above are handled asynchronously. Setting this field to `true` will make sure
       * refetched queries are completed before the mutation is considered done (or resolved).
       * https://www.apollographql.com/docs/react/api/react/hoc/#optionsawaitrefetchqueries
       */
      awaitRefetchQueries: false, // `false` by default

      /**
       * Taken from the docs vue-apollo docs verbatim:
       *
       * "A MutationQueryReducersMap, which is map from query names to mutation query reducers. Briefly,
       * this map defines how to incorporate the results of the mutation into the results of queries that
       * are currently being watched by your application."
       *
       * Seems to be this part from the Apollo Docs: https://www.apollographql.com/docs/react/api/react/hoc/#optionsupdatequeries
       * It'll be removed on the next major version of Apollo Client in favor of `update` above.
       */
      updateQueries: undefined,
    });

    onError((err) => {
      // Handle accordingly when errors occur
      console.error(err);
      hasSuccessfullyDeletedUser.value = false;
    });
    onDone((res) => {
      // Do some side effects when the query is successful
      console.log('Result from DemoUseMutation:', res);

      if (res.data?.deleteUser.user) {
        hasSuccessfullyDeletedUser.value = true;
      }
    });

    return {
      userId,
      deleteUser,
      error,
      isLoading,
      called,
      hasSuccessfullyDeletedUser,
    };
  },
});
export default DemoUseMutation;
</script>

<style lang="scss" scoped></style>
